C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\main.c LARGE OPTIMIZE(4,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          //======================================================
   2          // Main program routine
   3          // - Device name  : A94B114
   4          // - Package type : 20TSSOP
   5          //======================================================
   6          // For XDATA variable : V1.041.00 ~
   7          #define   MAIN  1
   8          
   9          // Generated    : Mon, Sep 02, 2019 (15:31:54)
  10          #include  "A94B114.h"
  11          #include "flash.h"
  12          #include  "func_def.h"
  13          #include  "MotorPara.h"
  14          
  15          extern unsigned char RemotePress,SleepTimerCompleteFlag_1hr,SleepTimerStartFlag_1hr,TimerStartFlag,LowVolt
             -ageResetFlag,Timer_Counter_Complete_Flag;
  16          unsigned char Command,LED_blink_Counter,LED_blink_Status,Fan_load_Healthy=1;
  17          extern unsigned int Timer5min,TimerHrsValue;
  18          extern long NewKey,SleepTimerCounter_1hr,General_Counter;
  19          extern xdata unsigned int ADC_Value;
  20          extern xdata unsigned int Fan_load_unhealthy_Counter;
  21          unsigned char OnceProgrameFlag,OneSecTimer;
  22          //struct variable var;
  23          struct RemoteStatus RemoteData;
  24          
  25          xdata unsigned char Fan_load_helathy_count,Fan_load_healthy_once_flag;
  26          
  27          void main()
  28          {
  29   1        unsigned char Var_Data[14];
  30   1        cli();            // disable INT. during peripheral setting
  31   1        port_init();      // initialize ports
  32   1        clock_init();     // initialize operation clock
  33   1        ExINT_init();     // initialize external interrupt
  34   1        Timer0_init();    // initialize Timer0
  35   1        Timer1_init();    // initialize Timer1
  36   1        ADC_init();       // initialize A/D convertor
  37   1        
  38   1        P2IO |= 0x03;
  39   1        P2PU |= 0x03;     // pullup
  40   1        P2 |= 0X03;
  41   1        I2C_Parameter_syllergy();
  42   1        I2C_Motor_Start();
  43   1        P2IO &= ~0x03;
  44   1        P2PU &= ~0X03;
  45   1        Flash_Read(TEST_WRITE_ADDRESS, &OnceProgrameFlag, 1);
  46   1        if(OnceProgrameFlag != 0xAA)
  47   1        {
  48   2          RemoteData.Power = 1;
  49   2          RemoteData.Light = 0;
  50   2          RemoteData.FanSpeed = 5;
  51   2          RemoteData.Timer_Hrs = 0;
  52   2          RemoteData.Sleep = 0;
  53   2          test_self_PGM();
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 2   

  54   2        }
  55   1        else
  56   1        {
  57   2          Flash_Read(TEST_WRITE_ADDRESS, &Var_Data, 14);
  58   2          RemoteData.Power = Var_Data[1];
  59   2          RemoteData.Light = Var_Data[2];
  60   2          RemoteData.FanSpeed = Var_Data[3];
  61   2          RemoteData.Timer_Hrs = Var_Data[4];
  62   2          RemoteData.Sleep = Var_Data[5]; 
  63   2          General_Counter = (Var_Data[6]) | (Var_Data[7]<<8) | (Var_Data[8]<<16) | (Var_Data[9]<<24);
  64   2          SleepTimerCounter_1hr = (Var_Data[10]) | (Var_Data[11]<<8) | (Var_Data[12]<<16) | (Var_Data[13]<<24);
  65   2        }
  66   1        LVI_init();       // initialize LVI, LVR
  67   1        sei(); 
  68   1        if(RemoteData.Light)
  69   1        {
  70   2          LED_ON;
  71   2        }
  72   1        // enable INT.
  73   1        SystemInitialization();
  74   1        // TODO: add your main code here
  75   1        
  76   1        while(1)
  77   1        {
  78   2      //    if(Fan_load_Healthy)
  79   2      //    {
  80   2      //      Fan_load_Line_Monitor();
  81   2      //    }
  82   2      //    if((Fan_load_Healthy == 0) && (Fan_load_unhealthy_Counter >= FAN_LOAD_UNHELATHY_STABLIZING_TIME))
  83   2      //    {
  84   2      //      Fan_load_Line_Monitor();
  85   2      //      Fan_load_unhealthy_Counter = 0;
  86   2      //    }
  87   2          if(RemotePress)
  88   2          {
  89   3            Command = RemoteGetKeyProcess(NewKey);
  90   3            //RemotePress = 0;
  91   3            NewKey = 0;
  92   3            LED_blink_Counter = 0;
  93   3            LED_blink_Status = 0;
  94   3            OneSecTimer = 0;
  95   3            LED_OFF;
  96   3            process();
  97   3            RemotePress = 0;
  98   3            Fan_load_healthy_once_flag = 0;
  99   3            LVI_De_init();
 100   3            test_self_PGM();
 101   3            LVI_init();
 102   3          }
 103   2          if((RemoteData.Sleep)&&(SleepTimerCompleteFlag_1hr))
 104   2          {
 105   3            SleepOperation();
 106   3            LVI_De_init();
 107   3            test_self_PGM();
 108   3            LVI_init();
 109   3          }
 110   2          if((SleepTimerStartFlag_1hr) || (TimerStartFlag))
 111   2          {
 112   3            if(Timer5min >= TIMER_5_MINUTES)
 113   3            {
 114   4              //write flash
 115   4              //test_self_PGM();
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 3   

 116   4              Timer5min = 0;
 117   4            }
 118   3          }
 119   2          if(Timer_Counter_Complete_Flag)
 120   2          {
 121   3            LED_blink_Counter = 2;
 122   3            LED_blink_Status = 1;
 123   3            fan_power_off();
 124   3            //i2c_speed(FAN_OFF_VALUE);
 125   3            Timer_Counter_Complete_Flag = 1;
 126   3            RemoteData.Power = 0;
 127   3            RemoteData.Timer_Hrs = REMOTE_TIMER_OFF;
 128   3            TimerStartFlag = 0;
 129   3            General_Counter = 0;
 130   3            TimerHrsValue = 0;
 131   3            Timer_Counter_Complete_Flag = 0;
 132   3          }
 133   2          if(LowVoltageResetFlag)
 134   2          {
 135   3            
 136   3            //LVI_De_init();
 137   3            //test_self_PGM();
 138   3            LowVoltageResetFlag = 0;
 139   3            //LVI_init();
 140   3          }
 141   2        }
 142   1      }
 143          
 144          void process()
 145          {
 146   1        switch(Command)
 147   1        {
 148   2          case POWER:
 149   2            //OPERTION
 150   2            fan_power_on();
 151   2            break;
 152   2          /*case LIGHT:
 153   2            //OPERTION
 154   2            if(RemoteData.Light)
 155   2            {
 156   2              RemoteData.Light = 0;
 157   2              LED_OFF;
 158   2            }
 159   2            else
 160   2            {
 161   2              RemoteData.Light = 1;
 162   2              LED_ON;
 163   2            }
 164   2            Command = 0;        
 165   2            break; */
 166   2          case FAN_SPEED_1:
 167   2            //OPERTION
 168   2            if(!RemoteData.Sleep)
 169   2              {   
 170   3                fanSpeed1();
 171   3              }
 172   2            Command = 0;        
 173   2            break;
 174   2          case FAN_SPEED_2:
 175   2            //OPERTION
 176   2            if(!RemoteData.Sleep)
 177   2              {   
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 4   

 178   3                fanSpeed2();
 179   3              }
 180   2            Command = 0;  
 181   2            break;
 182   2          case FAN_SPEED_3:
 183   2            //OPERTION
 184   2            if(!RemoteData.Sleep)
 185   2              {   
 186   3                fanSpeed3();
 187   3              }
 188   2            Command = 0;  
 189   2            break;
 190   2          case FAN_SPEED_4:
 191   2            //OPERTION      
 192   2            if(!RemoteData.Sleep)
 193   2              {   
 194   3                fanSpeed4();
 195   3              }
 196   2            Command = 0;  
 197   2            break;
 198   2          case FAN_SPEED_5:
 199   2            //OPERTION
 200   2            if(!RemoteData.Sleep)
 201   2              {   
 202   3                fanSpeed5();
 203   3              }
 204   2            Command = 0;  
 205   2            break;
 206   2          case FAN_SPEED_6:
 207   2            //OPERTION
 208   2            if(!RemoteData.Sleep)
 209   2              {   
 210   3                fanSpeed6();
 211   3              }
 212   2            Command = 0;  
 213   2            break;
 214   2          case BOOST:
 215   2            //OPERTION
 216   2            if(!RemoteData.Sleep)
 217   2              {   
 218   3                fanSpeed_BOOST();
 219   3              }
 220   2            Command = 0;  
 221   2            break;
 222   2          case TIME_2HRS:
 223   2            //OPERTION
 224   2            if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs != REMOTE_TIMER_2HRS))
 225   2            {       
 226   3              Timer_Hrs_process(REMOTE_TIMER_2HRS);
 227   3              RemoteData.Timer_Hrs = REMOTE_TIMER_2HRS;                 
 228   3            }
 229   2            else if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs == REMOTE_TIMER_2HRS))
 230   2            {
 231   3              Timer_Disable();          
 232   3            }
 233   2            Command = 0;
 234   2            break;
 235   2          case TIME_4HRS:
 236   2            //OPERTION
 237   2            if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs != REMOTE_TIMER_4HRS))
 238   2            {
 239   3              Timer_Hrs_process(REMOTE_TIMER_4HRS);
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 5   

 240   3              RemoteData.Timer_Hrs = REMOTE_TIMER_4HRS;                 
 241   3            }
 242   2            else if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs == REMOTE_TIMER_4HRS))
 243   2            {
 244   3              Timer_Disable();
 245   3            }
 246   2            Command = 0;
 247   2            break;
 248   2          /*case TIME_6HRS:
 249   2            //OPERTION
 250   2            if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs != REMOTE_TIMER_6HRS))
 251   2            {
 252   2              Timer_Hrs_process(REMOTE_TIMER_6HRS);
 253   2              RemoteData.Timer_Hrs = REMOTE_TIMER_6HRS;                 
 254   2            }
 255   2            else if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs == REMOTE_TIMER_6HRS))
 256   2            {
 257   2              Timer_Disable();  
 258   2            }
 259   2            Command = 0;
 260   2            break;*/
 261   2          case TIME_8HRS:
 262   2            //OPERTION
 263   2            if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs != REMOTE_TIMER_8HRS))
 264   2            {
 265   3              Timer_Hrs_process(REMOTE_TIMER_8HRS);
 266   3              RemoteData.Timer_Hrs = REMOTE_TIMER_8HRS;                 
 267   3            }
 268   2            else if((RemoteData.Power)&&(!RemoteData.Sleep)&&(RemoteData.Timer_Hrs == REMOTE_TIMER_8HRS))
 269   2            {
 270   3              Timer_Disable();  
 271   3            }
 272   2            Command = 0;
 273   2            break;
 274   2          case SLEEP_MODE:
 275   2            //OPERATION
 276   2            Timer_Disable();
 277   2            if((!RemoteData.Sleep) && (RemoteData.Power))
 278   2            {
 279   3              LED_blink_Counter = 4+(3*(RemoteData.Light));
 280   3              LED_blink_Status = 1;
 281   3              RemoteData.Sleep = 1;
 282   3              SleepTimerStartFlag_1hr =1;
 283   3              SleepTimerCompleteFlag_1hr = 0;
 284   3              SleepTimerCounter_1hr = 0;
 285   3              //Sleep operations
 286   3            }
 287   2            else
 288   2            {
 289   3              LED_blink_Counter = 2+(3*(RemoteData.Light));
 290   3              LED_blink_Status = 1;
 291   3              RemoteData.Sleep = 0;
 292   3              SleepTimerStartFlag_1hr = 0;
 293   3              SleepTimerCompleteFlag_1hr = 0;
 294   3              SleepTimerCounter_1hr = 0;
 295   3              // disable all the sleep operations
 296   3            }
 297   2            break;
 298   2            
 299   2                  
 300   2          /* case REVERSE_MODE:
 301   2              if(P0 & 0x40)
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 6   

 302   2              {
 303   2                P0 &= ~(1<<6);
 304   2              }
 305   2              else
 306   2              {
 307   2                P0 |= (1<<6);
 308   2              }
 309   2            break; */     
 310   2            
 311   2            
 312   2          default:
 313   2            //operation
 314   2          break;
 315   2            
 316   2        }
 317   1      }
 318          
 319          void SystemInitialization(void)
 320          {
 321   1        if(RemoteData.Power)
 322   1        {
 323   2          switch(RemoteData.FanSpeed)
 324   2          {
 325   3            case 0:
 326   3              //operation
 327   3              fan_power_off();
 328   3              //i2c_speed(FAN_OFF_VALUE);
 329   3              break;
 330   3            case 1:
 331   3              //operation
 332   3              fanSpeed1();
 333   3              break;
 334   3            case 2:
 335   3              //operation
 336   3              fanSpeed2();
 337   3              break;
 338   3            case 3:
 339   3              //operation
 340   3              fanSpeed3();
 341   3              break;
 342   3            case 4:
 343   3              //operation
 344   3              fanSpeed4();
 345   3              break;
 346   3            case 5:
 347   3              //operation
 348   3              fanSpeed5();
 349   3              break;
 350   3            case 6:
 351   3              //operation
 352   3              fanSpeed6();
 353   3              break;
 354   3            case 7:
 355   3              //operation
 356   3              fanSpeed_BOOST();
 357   3              break;
 358   3            default:
 359   3              //operation
 360   3              //not possible
 361   3              break;
 362   3          }
 363   2        }    
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 7   

 364   1        
 365   1      
 366   1        if(RemoteData.Timer_Hrs)
 367   1          
 368   1        {
 369   2          Timer_Hrs_process(RemoteData.Timer_Hrs);
 370   2          // timer start flag loaded
 371   2          // general counter value loaded
 372   2        }
 373   1        if( RemoteData.Sleep)
 374   1        {
 375   2          LED_blink_Counter = 4+(3*(RemoteData.Light));
 376   2          LED_blink_Status = 1;
 377   2          RemoteData.Sleep = 1;
 378   2          SleepTimerStartFlag_1hr =1;
 379   2          SleepTimerCompleteFlag_1hr = 0;   
 380   2        }
 381   1      }
 382          
 383          unsigned char current_speed;
 384          void Fan_load_Line_Monitor(void)
 385          {
 386   1        
 387   1        if(Fan_load_Healthy)  
 388   1        {
 389   2          if ((ADC_Value >= (FAN_LOAD_UNHEALTHY_VALUE)))
 390   2          {
 391   3            P2IO |= 0x03;
 392   3            P2PU |= 0x03;     // pullup
 393   3            P2 |= 0X03;
 394   3            Fan_load_Healthy = 0;
 395   3            current_speed = i2c_devicer(speedCtrl_Base_address);
 396   3            P2IO &= ~0x03;
 397   3            P2PU &= ~0X03;
 398   3            if(!Fan_load_healthy_once_flag)
 399   3            {
 400   4              current_speed = current_speed-10;
 401   4              i2c_speed(current_speed);
 402   4            }
 403   3            else if (Fan_load_healthy_once_flag)
 404   3            {
 405   4              if(ADC_Value <= (FAN_LOAD_UNHEALTHY_VALUE+3))
 406   4              {
 407   5                Fan_load_Healthy = 1;
 408   5              }
 409   4              else
 410   4              {
 411   5                Fan_load_Healthy = 0;
 412   5              }
 413   4            }
 414   3          }     
 415   2        }
 416   1        else
 417   1        {
 418   2          //Check wheateher AC is not in healthy state
 419   2          if((ADC_Value <= FAN_LOAD_HYSTERSIS_VALUE)||(ADC_Value < (FAN_LOAD_HEALTHY_VALUE-1)))
 420   2          {
 421   3            //Fan_load_Healthy = 1;
 422   3            if(current_speed < 255)
 423   3            { 
 424   4              current_speed = current_speed+1;
 425   4            }
C51 COMPILER V9.60.0.0   MAIN                                                              12/19/2022 10:49:28 PAGE 8   

 426   3            i2c_speed(current_speed);
 427   3            //SystemInitialization();
 428   3            //fan on in previous condition
 429   3          }
 430   2          else if((ADC_Value >= (FAN_LOAD_HEALTHY_VALUE-1)) && (ADC_Value <= (FAN_LOAD_UNHEALTHY_VALUE-5)))
 431   2          {
 432   3            Fan_load_helathy_count++;
 433   3            if(Fan_load_helathy_count >= 20)
 434   3            {
 435   4              Fan_load_helathy_count = 0;
 436   4              Fan_load_Healthy = 1; 
 437   4              Fan_load_healthy_once_flag = 1;
 438   4            }       
 439   3          }
 440   2          /*else if(ADC_Value >= FAN_LOAD_UNHEALTHY_VALUE+25)
 441   2          {
 442   2            current_speed = current_speed-10;
 443   2            i2c_speed(current_speed);
 444   2          }*/
 445   2          else
 446   2          {
 447   3            //lower the speed
 448   3            current_speed = current_speed-2;
 449   3            i2c_speed(current_speed);
 450   3          }
 451   2        }
 452   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1709    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     11      14
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
