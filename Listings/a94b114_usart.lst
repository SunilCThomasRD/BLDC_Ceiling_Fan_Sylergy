C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE A94B114_USART
OBJECT MODULE PLACED IN .\Objects\a94b114_usart.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\a94b114_usart.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PR
                    -INT(.\Listings\a94b114_usart.lst) TABS(2) OBJECT(.\Objects\a94b114_usart.obj)

line level    source

   1          /**
   2          *   @file       a94b114_usart.c
   3          *   @brief      a94b114 usart peripheral function 
   4          *   @author     Application Team, ABOV Semiconductor Co., Ltd.
   5          *   @version    V1.00
   6          *   @date       15. JAN. 2020
   7          *
   8          * Copyright(C) 2020, ABOV Semiconductor
   9          * All rights reserved.
  10          *
  11          ********************************************************************************
  12          * ABOV Disclaimer
  13          *
  14          *IMPORTANT NOTICE - PLEASE READ CAREFULLY
  15          *ABOV Semiconductor ("ABOV") reserves the right to make changes, corrections, enhancements, 
  16          *modifications, and improvements to ABOV products and/or to this document at any time without notice. 
  17          *ABOV does not give warranties as to the accuracy or completeness of the information included herein.
  18          *Purchasers should obtain the latest relevant information of ABOV products before placing orders. 
  19          *Purchasers are entirely responsible for the choice, selection, and use of ABOV products and 
  20          *ABOV assumes no liability for application assistance or the design of purchasers' products. No license, 
  21          *express or implied, to any intellectual property rights is granted by ABOV herein. 
  22          *ABOV disclaims all express and implied warranties and shall not be responsible or
  23          *liable for any injuries or damages related to use of ABOV products in such unauthorized applications. 
  24          *ABOV and the ABOV logo are trademarks of ABOV.
  25          *All other product or service names are the property of their respective owners. 
  26          *Information in this document supersedes and replaces the information previously
  27          *supplied in any former versions of this document.
  28          *2020 ABOV Semiconductor  All rights reserved
  29          *
  30          */
  31          
  32          /*******************************************************************************
  33          * Included File
  34          *******************************************************************************/
  35          #include "a94b114_usart.h"
  36          
  37          /*******************************************************************************
  38          * Private Pre-processor Definition & Macro
  39          *******************************************************************************/
  40          
  41          /*******************************************************************************
  42          * Private Typedef
  43          *******************************************************************************/
  44          
  45          /*******************************************************************************
  46          * Private Variable
  47          *******************************************************************************/
  48          char USART_tx_queue[ USART_QUEUE_SIZE ];
  49          char USART_tx_front, USART_tx_rear;
  50          
  51          char USART_rx_queue[ USART_QUEUE_SIZE ];
  52          char USART_rx_front, USART_rx_rear;
  53          /*******************************************************************************
  54          * Private Function Prototype
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 2   

  55          *******************************************************************************/
  56          char USART_tx_queue_is_full()
  57          {
  58   1        return ( (USART_tx_rear + 1 ) % USART_QUEUE_SIZE == USART_tx_front );
  59   1      }
  60          
  61          char USART_tx_queue_is_empty()
  62          {
  63   1        return ( USART_tx_rear == USART_tx_front );
  64   1      }
  65          
  66          char USART_rx_queue_is_full()
  67          {
  68   1        return ( (USART_rx_rear + 1 ) % USART_QUEUE_SIZE == USART_rx_front );
  69   1      }
  70          
  71          char USART_rx_queue_is_empty()
  72          {
  73   1        return ( USART_rx_rear == USART_rx_front );
  74   1      }
  75          
  76          /*******************************************************************************
  77          * Public Function
  78          *******************************************************************************/
  79          
  80          /**
  81          * @brief    Initialize usart peripheral(For USART & UART)
  82          * @param   speed      This parameter contains the buadrate of uart/usart.
  83          * @param   data_length  This parameter contains the length of data as uart/usart
  84          *
  85          *         - USART_DATA_5BIT = 0
  86          *         - USART_DATA_6BIT = 1
  87          *         - USART_DATA_7BIT = 2
  88          *         - USART_DATA_8BIT = 3
  89          *         - USART_DATA_9BIT = 7
  90          * @param   stop_bits  This parameter contains the bits of stop as uart/usart. 
  91          *
  92          *         - USART_STOP_1BIT = 0
  93          *         - USART_STOP_2BIT = 1
  94          * @param   parity This parameter contains the bit of parity as uart. 
  95          *
  96          *         - USART_PARITY_NO = 0
  97          *         - USART_PARITY_EVEN = 2
  98          *         - USART_PARITY_ODD = 3
  99          * @param   mode This parameter contains the enable of transmit or receive mode(uart/usart). 
 100          *
 101          *         - USART_TX_RX_MODE = 0
 102          *           - USART_RX_MODE = 1
 103          *         - USART_TX_MODE = 2
 104          * @return   None
 105          */
 106          void USART_Initial(uint32_t speed, uint8_t data_length, uint8_t stop_bits, uint8_t parity, uint8_t mode)
 107          {
 108   1        uint32_t buadrate_val = 0;
 109   1        uint8_t temp_reg, temp_reg2;
 110   1        
 111   1        temp_reg = UCTRL1;
 112   1        temp_reg &= ~(0x3 << 6);  
 113   1        //operation mode : UART(default), if used USART, set USART_Clock_Initial() + USART_Initial();
 114   1        temp_reg |= ((parity << 4) | (data_length <<  1));
 115   1        
 116   1        temp_reg2 = UCTRL2;
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 3   

 117   1        if(mode == USART_RX_MODE)
 118   1          temp_reg2 |= (1 << 2);  
 119   1        else if(mode == USART_TX_MODE)
 120   1          temp_reg2 |= (1 << 3);
 121   1        else
 122   1          temp_reg2 |= ((1 << 2) | (1 << 3));
 123   1        
 124   1        temp_reg2 |= (1 << 1);  
 125   1        
 126   1        //temp_reg2 |= (0x1 << 0); //if using Double Speed operation, Enable UCTRL2 |= (0x1 << 0)
 127   1        if(temp_reg2 & 0x1) //Double Speed operation(only UART)
 128   1        {
 129   2          buadrate_val = ((Clock_GetSystemFreq() / speed )  >> 3) * 10;
 130   2        }
 131   1        else if(temp_reg & 0x40) //Synchronous mode(USART)
 132   1        {
 133   2          buadrate_val = ((Clock_GetSystemFreq() / speed )  >> 1) * 10;
 134   2        }
 135   1        else  //Normal Speed operation
 136   1        {
 137   2          buadrate_val = ((Clock_GetSystemFreq() / speed )  >> 4) * 10;
 138   2        }
 139   1        
 140   1        buadrate_val = ((buadrate_val + 5) / 10) - 1; //round
 141   1        
 142   1        
 143   1        if(!(UCTRL1 & 0x40)) //Not Synchronous mode(USART)
 144   1          USTAT |= (1 << 3);      // USART block reset
 145   1        
 146   1        
 147   1        UCTRL1 = temp_reg;
 148   1        UCTRL3 |= (stop_bits<< 2);
 149   1        
 150   1        UBAUD = buadrate_val;
 151   1        
 152   1        UCTRL2 = temp_reg2; 
 153   1      }
 154          
 155          
 156          /**
 157          * @brief    Initialize the clock of usart peripheral(For only USART)
 158          * @param   clock_en This parameter contains the selection of USART mode.
 159          *
 160          *         - USART_SYNC_DISABLE = 0
 161          *         - USART_SYNC_ENABLE  = 1
 162          * @param   mode This parameter contains the enable of transmit or receive mode(uart/usart). 
 163          *
 164          *         - USART_SLAVE_MODE    = 0
 165          *         - USART_MASTER_MODE = 1
 166          * @return   None
 167          */
 168          void USART_Clock_Initial(uint32_t clock_en, uint8_t master_en)
 169          {
 170   1        uint8_t temp_reg, temp_reg2;
 171   1        
 172   1        temp_reg = UCTRL1;
 173   1        temp_reg &= ~(0x3 << 6);
 174   1        temp_reg |= (clock_en << 6);
 175   1        
 176   1        temp_reg2 = UCTRL3;
 177   1        temp_reg2 &= ~(0x1 << 7);
 178   1        temp_reg2 |= (master_en << 7);
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 4   

 179   1        
 180   1        USTAT |= (1 << 3);      // USART block reset
 181   1        
 182   1        UCTRL1 = temp_reg;
 183   1        UCTRL3 = temp_reg2;
 184   1      }
 185          
 186          /**
 187          * @brief    Enables or disables the USART peripheral.
 188          * @param   enable   This parameter contains the enable of this function. 
 189          *
 190          *         - FLASE                       = 0
 191          *         - TRUE                        = 1
 192          * @return   None
 193          */
 194          void USART_Enable(uint8_t enable)
 195          {
 196   1          if(enable == TRUE)
 197   1          {
 198   2            UCTRL2 |= (1 << 1);
 199   2          }
 200   1          else
 201   1          {
 202   2            UCTRL2 &= ~(1 << 1);
 203   2          }
 204   1      }
 205          
 206          
 207          /**
 208          * @brief    Transmit data through the USART peripheral for polling mode.
 209          * @param   send_data   This parameter contains the data to transmit. 
 210          * @param   count    This parameter contains the number of write length.
 211          * @return   None
 212          */
 213          void USART_SendDataWithPolling(uint8_t *send_data, uint8_t count)
 214          {
 215   1        uint8_t i;
 216   1        
 217   1        for(i = 0; i < count; i++)
 218   1        {
 219   2          while(!(USTAT & ((1 << 7))));
 220   2          UDATA = send_data[i];
 221   2        }
 222   1      }
 223          
 224          /**
 225          * @brief    Transmit data through the USART peripheral for interrupt mode.
 226          * @param   send_data   This parameter contains the data to transmit. 
 227          * @return   None
 228          */
 229          void USART_SendDataWithInterrupt(uint8_t send_data)
 230          {
 231   1        if( (UCTRL2 & ((1 << 7))) || (UCTRL2 & ((1 << 6))))           
 232   1        {
 233   2          if ( USART_tx_queue_is_empty() == FALSE )     
 234   2          {
 235   3            while ( USART_tx_queue_is_full() == TRUE ); 
 236   3                                 
 237   3                                
 238   3          }
 239   2      
 240   2          USART_ConfigureInterrupt(USART_TX_COMPLETE_INT, FALSE);
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 5   

 241   2          
 242   2          USART_tx_queue [ USART_tx_rear ] = send_data;       
 243   2          USART_tx_rear = ++USART_tx_rear % USART_QUEUE_SIZE;           
 244   2          USART_ConfigureInterrupt(USART_TX_COMPLETE_INT, TRUE);
 245   2          
 246   2          UCTRL2 |= ((1 << 7)); 
 247   2        } 
 248   1      }
 249          
 250          /**
 251          * @brief    Receive data through the USART peripheral for polling mode.
 252          * @param   receive_data   This parameter contains the data to receive. 
 253          * @param   count    This parameter contains the number of receive length.
 254          * @return   received data
 255          */
 256          void USART_ReceiveDataWithPolling(uint8_t *receive_data, uint8_t count)
 257          {
 258   1        uint8_t i;
 259   1        
 260   1        for(i = 0; i < count; i++)
 261   1        {
 262   2          while(( USTAT & (1 << 5))!= (1 << 5));    // Wait Data in
 263   2          receive_data[i] = UDATA;
 264   2        }
 265   1      
 266   1      }
 267          
 268          /**
 269          * @brief    Receive data through the USART peripheral for interrupt mode.
 270          * @param   receive_data   This parameter contains the data to receive. 
 271          * @return   received data
 272          */
 273          uint8_t USART_ReceiveDataWithInterrupt(void)
 274          {
 275   1        uint8_t temp;
 276   1        
 277   1        while ( USART_rx_queue_is_empty() == TRUE ); 
 278   1      
 279   1        USART_ConfigureInterrupt(USART_RX_COMPLETE_INT, FALSE);
 280   1        temp = USART_rx_queue [ USART_rx_front ];
 281   1      
 282   1        USART_rx_front = ++USART_rx_front % USART_QUEUE_SIZE;
 283   1        USART_ConfigureInterrupt(USART_RX_COMPLETE_INT, TRUE);
 284   1      
 285   1        return temp;
 286   1      }
 287          
 288          /**
 289          * @brief    Configure the enable or disable USART interrupt.
 290          * @param   flag   This parameter contains the selection of this function. 
 291          *
 292          *         - USART_RX_COMPLETE_INT = 0
 293          *         - USART_TX_COMPLETE_INT = 1
 294          *           - USART_DATA_EMPTY_INT = 2
 295          *           - USART_WAKEUP_INT = 3
 296          * @param   enable   This parameter contains the enable of this function. 
 297          *
 298          *         - FLASE                       = 0
 299          *         - TRUE                        = 1
 300          * @return   None
 301          */
 302          void USART_ConfigureInterrupt(uint8_t flag, uint8_t enable)
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 6   

 303          {
 304   1        uint8_t temp_reg, temp_reg2;
 305   1      
 306   1        if(flag == USART_TX_COMPLETE_INT)
 307   1        {
 308   2          temp_reg = IE1;
 309   2          temp_reg &= ~(0x1 << 2);
 310   2          temp_reg |= (enable << 2);
 311   2          
 312   2          temp_reg2 = UCTRL2;
 313   2          temp_reg2 &= ~(0x1 << (5 + flag));
 314   2          temp_reg2 |= (enable << (5 + flag));
 315   2          
 316   2          IE1 = temp_reg;
 317   2          UCTRL2 = temp_reg2;
 318   2        }
 319   1        else if(flag == USART_RX_COMPLETE_INT)
 320   1        {
 321   2          temp_reg = IE1;
 322   2          temp_reg &= ~(0x1 << 1);
 323   2          temp_reg |= (enable << 1);
 324   2          
 325   2          temp_reg2 = UCTRL2;
 326   2          temp_reg2 &= ~(0x1 << (5 + flag));
 327   2          temp_reg2 |= (enable << (5 + flag));
 328   2          
 329   2          IE1 = temp_reg;
 330   2          UCTRL2 = temp_reg2;
 331   2        }
 332   1        else if(flag == USART_DATA_EMPTY_INT)
 333   1        {
 334   2          temp_reg = UCTRL2;
 335   2          temp_reg &= ~(0x1 << (5 + flag));
 336   2          temp_reg |= (enable << (5 + flag));
 337   2          UCTRL2 = temp_reg;
 338   2        }
 339   1        else if(flag == USART_WAKEUP_INT)
 340   1        {
 341   2          temp_reg = UCTRL2;
 342   2          temp_reg &= ~(0x1 << 4);
 343   2          temp_reg |= (enable << 4);
 344   2          UCTRL2 = temp_reg;
 345   2        }
 346   1      }
 347          
 348          /**
 349          * @brief    Get the USART interrupt status.
 350          * @return   Value of status(interrupt flag)
 351          */
 352          uint8_t USART_GetInterruptStatus(void)
 353          {
 354   1        uint8_t result;
 355   1        
 356   1        result = USTAT;
 357   1        
 358   1        return result;
 359   1      }
 360          
 361          /**
 362          * @brief    Set the function of wake up interrupt.
 363          * @param   enable   This parameter contains the enable of this function. 
 364          *
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 7   

 365          *         - FLASE                       = 0
 366          *         - TRUE    
 367          * @return   None
 368          
 369          */
 370          void USART_ConfigureWakeUp(uint8_t enable)
 371          {
 372   1        uint8_t temp_reg;
 373   1        
 374   1        temp_reg = UCTRL2;
 375   1        temp_reg &= ~(1 << 4);
 376   1        temp_reg |= (enable << 4);
 377   1        
 378   1        UCTRL2 = temp_reg;
 379   1      }
 380          
 381          /**
 382          * @brief    Clear the flag of wake up interrupt.
 383          * @param      None  
 384          * @return   None
 385          
 386          */
 387          void USART2_ClearWakeUpFlag(void)
 388          {
 389   1        USTAT &= ~(1 << 4);
 390   1      }
 391          
 392          
 393          /**
 394          * @brief    Compensation the baud rate of UART(special function)
 395          * @param   fpcg_val   This parameter contains the floating point counter of this function. 
 396          * @param   enable   This parameter contains the enable of this function. 
 397          *
 398          *         - FLASE                       = 0
 399          *         - TRUE                        = 1
 400          * @return   None
 401          */
 402          void USART_CompensationBaudrate(uint16_t fpcg_val, uint8_t enable)
 403          {
 404   1        if(enable == TRUE)
 405   1        {
 406   2          UCTRL4 |= (1 << 2);
 407   2          FPCR = fpcg_val;
 408   2        }
 409   1        else
 410   1        {
 411   2          UCTRL4 &= ~(1 << 2);
 412   2          FPCR = 0;
 413   2        }
 414   1      }
 415          
 416          
 417          //==============================================================================
 418          // interrupt routines
 419          //==============================================================================
 420          void USART_RXInt_Handler() interrupt USART_RX_VECT
 421          { 
 422   1        unsigned char temp, temp2;
 423   1        
 424   1        temp    = USTAT;
 425   1        temp2   = UCTRL2;
 426   1        
C51 COMPILER V9.60.0.0   A94B114_USART                                                     12/19/2022 17:43:50 PAGE 8   

 427   1        if ( USART_rx_queue_is_full () )
 428   1        {
 429   2          if ((temp & (1 << 2) )||(temp & (1 << 1) )||(temp & (1 << 0) ))
 430   2          {
 431   3            USART_rx_queue [ USART_rx_rear ] = UDATA;
 432   3            USART_rx_rear = ++USART_rx_rear % USART_QUEUE_SIZE;
 433   3          }
 434   2          USART_rx_queue [ USART_rx_rear ] = UDATA;
 435   2          USART_rx_rear = ++USART_rx_rear % USART_QUEUE_SIZE;
 436   2            
 437   2          USART_rx_front = USART_rx_rear = 0; 
 438   2          USART_rx_queue[ USART_rx_front ] = 0;
 439   2        }
 440   1        else
 441   1        {
 442   2          USART_rx_queue [ USART_rx_rear ] = UDATA;
 443   2          USART_rx_rear = ++USART_rx_rear % USART_QUEUE_SIZE;
 444   2        }
 445   1      }
 446          
 447          void USART_TXInt_Handler() interrupt USART_TX_VECT
 448          {
 449   1        if ( USART_tx_queue_is_empty() == TRUE )
 450   1        {
 451   2          if ( (USTAT & ((1 << 6))) )       
 452   2          {
 453   3            UCTRL2  &= ~( ((1 << 7)) | ((1 << 6)) );
 454   3            USTAT &= ~( (1 << 7) + (1 << 6) );
 455   3          }
 456   2          else                
 457   2          {
 458   3            UCTRL2  &= ~( (1 << 7) );     
 459   3                            
 460   3          }
 461   2        }
 462   1        else
 463   1        {
 464   2          UDATA = USART_tx_queue [ USART_tx_front ];
 465   2          USART_tx_queue [ USART_tx_front ] = 0;
 466   2          USART_tx_front = ++USART_tx_front % USART_QUEUE_SIZE;
 467   2        }
 468   1      }
 469          
 470          
 471          /* --------------------------------- End Of File ------------------------------ */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1303    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     20      29
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
