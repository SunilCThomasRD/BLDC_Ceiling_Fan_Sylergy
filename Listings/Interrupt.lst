C51 COMPILER V9.60.0.0   INTERRUPT                                                         12/19/2022 10:49:28 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE INTERRUPT
OBJECT MODULE PLACED IN .\Objects\Interrupt.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\Interrupt.c LARGE OPTIMIZE(4,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(
                    -.\Listings\Interrupt.lst) TABS(2) OBJECT(.\Objects\Interrupt.obj)

line level    source

   1          #include  "A94B114.h"
   2          #include  "func_def.h"
   3          #include  "MotorPara.h"
   4          //======================================================
   5          // interrupt routines
   6          //======================================================
   7          
   8          int timerValue,pulseCount;
   9          long bitPattern,NewKey,SleepTimerCounter_1hr,General_Counter;
  10          unsigned char RemotePress,ADC250usCount;
  11          
  12          extern unsigned char OneSecTimer,Command,LED_blink_Counter,LED_blink_Status;
  13          
  14          unsigned char TimerStartFlag,SleepTimerCompleteFlag_1hr,SleepTimerStartFlag_1hr,LowVoltageResetFlag,Timer_
             -Counter_Complete_Flag;
  15          unsigned int TimerHrsValue,Timer5min,msCount=0;
  16          
  17          extern struct RemoteStatus RemoteData;
  18          xdata unsigned int Fan_load_unhealthy_Counter;
  19          
  20          void INT_Ext10() interrupt 1
  21          {
  22   1        if(!RemotePress)
  23   1        {
  24   2        timerValue = msCount;
  25   2        msCount = 0;
  26   2        pulseCount++;
  27   2        if((timerValue>=200)) // If the pulse width is greater than 50ms, this will mark the SOF
  28   2        { 
  29   3          pulseCount = -2; // First 2 counts needs to be skipped hence pulse ocunt is set to -2 
  30   3          bitPattern = 0;
  31   3        }
  32   2        else if((pulseCount>=0) && (pulseCount<32)) //Accumulate the bit values between 0-31.
  33   2        {   
  34   3          if(timerValue>=8)                      //pulse width greater than 2ms is considered as LOGIC1
  35   3          {
  36   4            bitPattern |=(long) 1<<(31-pulseCount);
  37   4          }
  38   3          else
  39   3          {
  40   4          }
  41   3        }
  42   2        else if(pulseCount>=32)                  //This will mark the End of frame as 32 pulses are received
  43   2        {
  44   3          NewKey = bitPattern;                // Copy the newKey(patter) and set the pulse count to 0;
  45   3          pulseCount = 0;
  46   3          RemotePress = 1;
  47   3        }
  48   2        }
  49   1        // External interrupt 10
  50   1        // TODO: add your code here
  51   1      }
  52          
  53          void INT_Timer0() interrupt 9
C51 COMPILER V9.60.0.0   INTERRUPT                                                         12/19/2022 10:49:28 PAGE 2   

  54          {
  55   1        if(msCount <= 250)
  56   1        {
  57   2          msCount++;
  58   2        }
  59   1        ADC250usCount++;
  60   1        //Fan_load_unhealthy_Counter++;
  61   1        if (ADC250usCount >= 100)
  62   1        {
  63   2          ADC_start(8);
  64   2          ADC250usCount = 0;
  65   2          Fan_load_unhealthy_Counter++;
  66   2        }   
  67   1        // Timer0 interrupt
  68   1        // TODO: add your code here
  69   1      }
  70          
  71          
  72          void INT_Timer1() interrupt 10        // 250msec interrupt
  73          {
  74   1        if(LED_blink_Counter)
  75   1        {
  76   2          if(OneSecTimer % 2 == 0)
  77   2          {
  78   3            LED_ON;
  79   3          }
  80   2          else
  81   2          {
  82   3            LED_OFF;
  83   3          }
  84   2          LED_blink_Counter--;
  85   2        }
  86   1        if((LED_blink_Status) && (LED_blink_Counter > 0))
  87   1        {
  88   2          OneSecTimer++;
  89   2        }
  90   1        else
  91   1        {
  92   2          OneSecTimer = 0;
  93   2          LED_blink_Status = 0;
  94   2          LED_blink_Counter = 0;
  95   2          if(RemoteData.Light)
  96   2          {
  97   3            LED_ON;
  98   3          }
  99   2        }
 100   1        
 101   1        if(TimerStartFlag)
 102   1        {
 103   2          General_Counter++;
 104   2          Timer5min++;
 105   2          if(General_Counter >= TimerHrsValue)
 106   2          {
 107   3            /*LED_blink_Counter = 2;
 108   3            LED_blink_Status = 1;
 109   3            //fan_power_off();
 110   3            //i2c_speed(FAN_OFF_VALUE);
 111   3            Timer_Counter_Complete_Flag = 1;
 112   3            RemoteData.Power = 0;
 113   3            RemoteData.Timer_Hrs = REMOTE_TIMER_OFF;
 114   3            TimerStartFlag = 0;
 115   3            General_Counter = 0;
C51 COMPILER V9.60.0.0   INTERRUPT                                                         12/19/2022 10:49:28 PAGE 3   

 116   3            TimerHrsValue = 0;*/
 117   3            Timer_Counter_Complete_Flag = 1;
 118   3          }
 119   2        }
 120   1        if(SleepTimerStartFlag_1hr)
 121   1        {
 122   2          SleepTimerCounter_1hr++;
 123   2          Timer5min++;
 124   2          if(SleepTimerCounter_1hr >= SLEEP_ONE_HOUR_TIMER1_VALUE)
 125   2          {
 126   3            SleepTimerCompleteFlag_1hr = 1;
 127   3            SleepTimerCounter_1hr = 0;
 128   3          }   
 129   2        }
 130   1        // Timer1 interrupt
 131   1        // TODO: add your code here
 132   1      }
 133          
 134          unsigned int adcVal = 0;
 135          xdata long ADCdata;
 136          xdata unsigned int ADC_Value = 0;
 137          
 138          void INT_ADC() interrupt 12
 139          { 
 140   1        static unsigned char SamplesTaken = 0;
 141   1        xdata long temp = 0;
 142   1        //long temp,ADCdata;
 143   1        // ADC interrupt
 144   1        // TODO: add your code here
 145   1        adcVal = (ADCRH << 8) | ADCRL;
 146   1        ADCdata += adcVal;
 147   1        SamplesTaken++;
 148   1        if(SamplesTaken >= ADC_SAMPLES)
 149   1        {
 150   2          ADCdata = ADCdata/ADC_SAMPLES;
 151   2          temp = (long)250*ADCdata;
 152   2          temp = temp/4096;
 153   2          ADC_Value = (unsigned int)temp;
 154   2          SamplesTaken = 0;
 155   2          ADCdata = 0;
 156   2        }
 157   1        ADCM &= ~0x40;    // stop ADC
 158   1        
 159   1      }
 160          
 161          
 162          
 163          void INT_LVI() interrupt 15
 164          {
 165   1        // LVI interrupt
 166   1        // TODO: add your code here
 167   1        LowVoltageResetFlag = 1;
 168   1        
 169   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1029    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     44       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.60.0.0   INTERRUPT                                                         12/19/2022 10:49:28 PAGE 4   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
